// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ERROR_KIND: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ERROR_KIND: i8 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ERROR_KIND: [ErrorKind; 8] = [
    ErrorKind::Failed,
    ErrorKind::NodeUnreachable,
    ErrorKind::Timeout,
    ErrorKind::UnknownMessageType,
    ErrorKind::Permissions,
    ErrorKind::KeyPermissions,
    ErrorKind::Serialization,
    ErrorKind::BadRequestId,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ErrorKind(pub i8);
#[allow(non_upper_case_globals)]
impl ErrorKind {
    pub const Failed: Self = Self(0);
    pub const NodeUnreachable: Self = Self(1);
    pub const Timeout: Self = Self(2);
    pub const UnknownMessageType: Self = Self(3);
    pub const Permissions: Self = Self(4);
    pub const KeyPermissions: Self = Self(5);
    pub const Serialization: Self = Self(6);
    pub const BadRequestId: Self = Self(7);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Failed,
        Self::NodeUnreachable,
        Self::Timeout,
        Self::UnknownMessageType,
        Self::Permissions,
        Self::KeyPermissions,
        Self::Serialization,
        Self::BadRequestId,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Failed => Some("Failed"),
            Self::NodeUnreachable => Some("NodeUnreachable"),
            Self::Timeout => Some("Timeout"),
            Self::UnknownMessageType => Some("UnknownMessageType"),
            Self::Permissions => Some("Permissions"),
            Self::KeyPermissions => Some("KeyPermissions"),
            Self::Serialization => Some("Serialization"),
            Self::BadRequestId => Some("BadRequestId"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ErrorKind {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ErrorKind {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ErrorKind {
    type Output = ErrorKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ErrorKind {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ErrorKind {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ErrorKind {}
// struct Sample, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Sample(pub [u8; 16]);
impl Default for Sample {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for Sample {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sample")
            .field("timestamp", &self.timestamp())
            .field("value", &self.value())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Sample {}
impl<'a> flatbuffers::Follow<'a> for Sample {
    type Inner = &'a Sample;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Sample>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Sample {
    type Inner = &'a Sample;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Sample>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Sample {
    type Output = Sample;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const Sample as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for Sample {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Sample {
    #[allow(clippy::too_many_arguments)]
    pub fn new(timestamp: i64, value: f64) -> Self {
        let mut s = Self([0; 16]);
        s.set_timestamp(timestamp);
        s.set_value(value);
        s
    }

    pub fn timestamp(&self) -> i64 {
        let mut mem = core::mem::MaybeUninit::<<i64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_timestamp(&mut self, x: i64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn value(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_value(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum LabelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Label<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Label<'a> {
    type Inner = Label<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Label<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Label { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LabelArgs<'args>,
    ) -> flatbuffers::WIPOffset<Label<'bldr>> {
        let mut builder = LabelBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Label::VT_NAME, None)
        }
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Label::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for Label<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct LabelArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LabelArgs<'a> {
    #[inline]
    fn default() -> Self {
        LabelArgs {
            name: None,
            value: None,
        }
    }
}

pub struct LabelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LabelBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Label::VT_NAME, name);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Label::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LabelBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LabelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Label<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Label<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Label");
        ds.field("name", &self.name());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum MGetValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MGetValue<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MGetValue<'a> {
    type Inner = MGetValue<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MGetValue<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_LABELS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MGetValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MGetValueArgs<'args>,
    ) -> flatbuffers::WIPOffset<MGetValue<'bldr>> {
        let mut builder = MGetValueBuilder::new(_fbb);
        if let Some(x) = args.labels {
            builder.add_labels(x);
        }
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(MGetValue::VT_KEY, None)
        }
    }
    #[inline]
    pub fn value(&self) -> Option<&'a Sample> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Sample>(MGetValue::VT_VALUE, None) }
    }
    #[inline]
    pub fn labels(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label>>,
            >>(MGetValue::VT_LABELS, None)
        }
    }
}

impl flatbuffers::Verifiable for MGetValue<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<Sample>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Label>>,
            >>("labels", Self::VT_LABELS, false)?
            .finish();
        Ok(())
    }
}
pub struct MGetValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<&'a Sample>,
    pub labels: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label<'a>>>>,
    >,
}
impl<'a> Default for MGetValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        MGetValueArgs {
            key: None,
            value: None,
            labels: None,
        }
    }
}

pub struct MGetValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MGetValueBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MGetValue::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: &Sample) {
        self.fbb_
            .push_slot_always::<&Sample>(MGetValue::VT_VALUE, value);
    }
    #[inline]
    pub fn add_labels(
        &mut self,
        labels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Label<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MGetValue::VT_LABELS, labels);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MGetValueBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MGetValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MGetValue<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MGetValue<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MGetValue");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("labels", &self.labels());
        ds.finish()
    }
}
pub enum SeriesResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SeriesResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SeriesResponse<'a> {
    type Inner = SeriesResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SeriesResponse<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_GROUP_LABEL_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_SAMPLES: flatbuffers::VOffsetT = 8;
    pub const VT_LABELS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SeriesResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SeriesResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<SeriesResponse<'bldr>> {
        let mut builder = SeriesResponseBuilder::new(_fbb);
        if let Some(x) = args.labels {
            builder.add_labels(x);
        }
        if let Some(x) = args.samples {
            builder.add_samples(x);
        }
        if let Some(x) = args.group_label_value {
            builder.add_group_label_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SeriesResponse::VT_KEY, None)
        }
    }
    #[inline]
    pub fn group_label_value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                SeriesResponse::VT_GROUP_LABEL_VALUE,
                None,
            )
        }
    }
    #[inline]
    pub fn samples(&self) -> Option<flatbuffers::Vector<'a, Sample>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Sample>>>(
                    SeriesResponse::VT_SAMPLES,
                    None,
                )
        }
    }
    #[inline]
    pub fn labels(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label>>,
            >>(SeriesResponse::VT_LABELS, None)
        }
    }
}

impl flatbuffers::Verifiable for SeriesResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "group_label_value",
                Self::VT_GROUP_LABEL_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Sample>>>(
                "samples",
                Self::VT_SAMPLES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Label>>,
            >>("labels", Self::VT_LABELS, false)?
            .finish();
        Ok(())
    }
}
pub struct SeriesResponseArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub group_label_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub samples: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Sample>>>,
    pub labels: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label<'a>>>>,
    >,
}
impl<'a> Default for SeriesResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        SeriesResponseArgs {
            key: None,
            group_label_value: None,
            samples: None,
            labels: None,
        }
    }
}

pub struct SeriesResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SeriesResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SeriesResponse::VT_KEY, key);
    }
    #[inline]
    pub fn add_group_label_value(&mut self, group_label_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SeriesResponse::VT_GROUP_LABEL_VALUE,
            group_label_value,
        );
    }
    #[inline]
    pub fn add_samples(
        &mut self,
        samples: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Sample>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SeriesResponse::VT_SAMPLES, samples);
    }
    #[inline]
    pub fn add_labels(
        &mut self,
        labels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Label<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SeriesResponse::VT_LABELS, labels);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SeriesResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SeriesResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SeriesResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SeriesResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SeriesResponse");
        ds.field("key", &self.key());
        ds.field("group_label_value", &self.group_label_value());
        ds.field("samples", &self.samples());
        ds.field("labels", &self.labels());
        ds.finish()
    }
}
pub enum MultiGetResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiGetResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiGetResponse<'a> {
    type Inner = MultiGetResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MultiGetResponse<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MultiGetResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MultiGetResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<MultiGetResponse<'bldr>> {
        let mut builder = MultiGetResponseBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MGetValue<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MGetValue>>,
            >>(MultiGetResponse::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for MultiGetResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MGetValue>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct MultiGetResponseArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MGetValue<'a>>>,
        >,
    >,
}
impl<'a> Default for MultiGetResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        MultiGetResponseArgs { values: None }
    }
}

pub struct MultiGetResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiGetResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MGetValue<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MultiGetResponse::VT_VALUES, values);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MultiGetResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MultiGetResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MultiGetResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MultiGetResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MultiGetResponse");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum SeriesRangeResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SeriesRangeResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SeriesRangeResponse<'a> {
    type Inner = SeriesRangeResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SeriesRangeResponse<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_SAMPLES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SeriesRangeResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SeriesRangeResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<SeriesRangeResponse<'bldr>> {
        let mut builder = SeriesRangeResponseBuilder::new(_fbb);
        if let Some(x) = args.samples {
            builder.add_samples(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SeriesRangeResponse::VT_KEY, None)
        }
    }
    #[inline]
    pub fn samples(&self) -> Option<flatbuffers::Vector<'a, Sample>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Sample>>>(
                    SeriesRangeResponse::VT_SAMPLES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for SeriesRangeResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Sample>>>(
                "samples",
                Self::VT_SAMPLES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SeriesRangeResponseArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub samples: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Sample>>>,
}
impl<'a> Default for SeriesRangeResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        SeriesRangeResponseArgs {
            key: None,
            samples: None,
        }
    }
}

pub struct SeriesRangeResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SeriesRangeResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SeriesRangeResponse::VT_KEY, key);
    }
    #[inline]
    pub fn add_samples(
        &mut self,
        samples: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Sample>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SeriesRangeResponse::VT_SAMPLES,
            samples,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SeriesRangeResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SeriesRangeResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SeriesRangeResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SeriesRangeResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SeriesRangeResponse");
        ds.field("key", &self.key());
        ds.field("samples", &self.samples());
        ds.finish()
    }
}
pub enum RangeResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeResponse<'a> {
    type Inner = RangeResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RangeResponse<'a> {
    pub const VT_SERIES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RangeResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RangeResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<RangeResponse<'bldr>> {
        let mut builder = RangeResponseBuilder::new(_fbb);
        if let Some(x) = args.series {
            builder.add_series(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn series(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SeriesRangeResponse<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SeriesRangeResponse>>,
            >>(RangeResponse::VT_SERIES, None)
        }
    }
}

impl flatbuffers::Verifiable for RangeResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SeriesRangeResponse>>,
            >>("series", Self::VT_SERIES, false)?
            .finish();
        Ok(())
    }
}
pub struct RangeResponseArgs<'a> {
    pub series: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SeriesRangeResponse<'a>>>,
        >,
    >,
}
impl<'a> Default for RangeResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        RangeResponseArgs { series: None }
    }
}

pub struct RangeResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RangeResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_series(
        &mut self,
        series: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SeriesRangeResponse<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RangeResponse::VT_SERIES, series);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RangeResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RangeResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RangeResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RangeResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RangeResponse");
        ds.field("series", &self.series());
        ds.finish()
    }
}
pub enum MultiRangeResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiRangeResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiRangeResponse<'a> {
    type Inner = MultiRangeResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MultiRangeResponse<'a> {
    pub const VT_SERIES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MultiRangeResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MultiRangeResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<MultiRangeResponse<'bldr>> {
        let mut builder = MultiRangeResponseBuilder::new(_fbb);
        if let Some(x) = args.series {
            builder.add_series(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn series(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SeriesResponse<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SeriesResponse>>,
            >>(MultiRangeResponse::VT_SERIES, None)
        }
    }
}

impl flatbuffers::Verifiable for MultiRangeResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SeriesResponse>>,
            >>("series", Self::VT_SERIES, false)?
            .finish();
        Ok(())
    }
}
pub struct MultiRangeResponseArgs<'a> {
    pub series: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SeriesResponse<'a>>>,
        >,
    >,
}
impl<'a> Default for MultiRangeResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        MultiRangeResponseArgs { series: None }
    }
}

pub struct MultiRangeResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiRangeResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_series(
        &mut self,
        series: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SeriesResponse<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MultiRangeResponse::VT_SERIES, series);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MultiRangeResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MultiRangeResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MultiRangeResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MultiRangeResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MultiRangeResponse");
        ds.field("series", &self.series());
        ds.finish()
    }
}
pub enum IndexQueryResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IndexQueryResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IndexQueryResponse<'a> {
    type Inner = IndexQueryResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IndexQueryResponse<'a> {
    pub const VT_KEYS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IndexQueryResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args IndexQueryResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<IndexQueryResponse<'bldr>> {
        let mut builder = IndexQueryResponseBuilder::new(_fbb);
        if let Some(x) = args.keys {
            builder.add_keys(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn keys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(IndexQueryResponse::VT_KEYS, None)
        }
    }
}

impl flatbuffers::Verifiable for IndexQueryResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("keys", Self::VT_KEYS, false)?
            .finish();
        Ok(())
    }
}
pub struct IndexQueryResponseArgs<'a> {
    pub keys: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for IndexQueryResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        IndexQueryResponseArgs { keys: None }
    }
}

pub struct IndexQueryResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IndexQueryResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_keys(
        &mut self,
        keys: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexQueryResponse::VT_KEYS, keys);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> IndexQueryResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        IndexQueryResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IndexQueryResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IndexQueryResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IndexQueryResponse");
        ds.field("keys", &self.keys());
        ds.finish()
    }
}
pub enum ErrorResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ErrorResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ErrorResponse<'a> {
    type Inner = ErrorResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ErrorResponse<'a> {
    pub const VT_KIND: flatbuffers::VOffsetT = 4;
    pub const VT_EXTRA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ErrorResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ErrorResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<ErrorResponse<'bldr>> {
        let mut builder = ErrorResponseBuilder::new(_fbb);
        if let Some(x) = args.extra {
            builder.add_extra(x);
        }
        builder.add_kind(args.kind);
        builder.finish()
    }

    #[inline]
    pub fn kind(&self) -> ErrorKind {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ErrorKind>(ErrorResponse::VT_KIND, Some(ErrorKind::Failed))
                .unwrap()
        }
    }
    #[inline]
    pub fn extra(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ErrorResponse::VT_EXTRA, None)
        }
    }
}

impl flatbuffers::Verifiable for ErrorResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<ErrorKind>("kind", Self::VT_KIND, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("extra", Self::VT_EXTRA, false)?
            .finish();
        Ok(())
    }
}
pub struct ErrorResponseArgs<'a> {
    pub kind: ErrorKind,
    pub extra: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        ErrorResponseArgs {
            kind: ErrorKind::Failed,
            extra: None,
        }
    }
}

pub struct ErrorResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_kind(&mut self, kind: ErrorKind) {
        self.fbb_
            .push_slot::<ErrorKind>(ErrorResponse::VT_KIND, kind, ErrorKind::Failed);
    }
    #[inline]
    pub fn add_extra(&mut self, extra: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ErrorResponse::VT_EXTRA, extra);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ErrorResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ErrorResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ErrorResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ErrorResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ErrorResponse");
        ds.field("kind", &self.kind());
        ds.field("extra", &self.extra());
        ds.finish()
    }
}
pub enum LabelValuesResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LabelValuesResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LabelValuesResponse<'a> {
    type Inner = LabelValuesResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LabelValuesResponse<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LabelValuesResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LabelValuesResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<LabelValuesResponse<'bldr>> {
        let mut builder = LabelValuesResponseBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(LabelValuesResponse::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for LabelValuesResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct LabelValuesResponseArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for LabelValuesResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        LabelValuesResponseArgs { values: None }
    }
}

pub struct LabelValuesResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LabelValuesResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(LabelValuesResponse::VT_VALUES, values);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> LabelValuesResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LabelValuesResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LabelValuesResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LabelValuesResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LabelValuesResponse");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum LabelNamesResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LabelNamesResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LabelNamesResponse<'a> {
    type Inner = LabelNamesResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LabelNamesResponse<'a> {
    pub const VT_NAMES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LabelNamesResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LabelNamesResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<LabelNamesResponse<'bldr>> {
        let mut builder = LabelNamesResponseBuilder::new(_fbb);
        if let Some(x) = args.names {
            builder.add_names(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(LabelNamesResponse::VT_NAMES, None)
        }
    }
}

impl flatbuffers::Verifiable for LabelNamesResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("names", Self::VT_NAMES, false)?
            .finish();
        Ok(())
    }
}
pub struct LabelNamesResponseArgs<'a> {
    pub names: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for LabelNamesResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        LabelNamesResponseArgs { names: None }
    }
}

pub struct LabelNamesResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LabelNamesResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_names(
        &mut self,
        names: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(LabelNamesResponse::VT_NAMES, names);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> LabelNamesResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LabelNamesResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LabelNamesResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LabelNamesResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LabelNamesResponse");
        ds.field("names", &self.names());
        ds.finish()
    }
}
pub enum CardinalityResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CardinalityResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CardinalityResponse<'a> {
    type Inner = CardinalityResponse<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CardinalityResponse<'a> {
    pub const VT_COUNT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CardinalityResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CardinalityResponseArgs,
    ) -> flatbuffers::WIPOffset<CardinalityResponse<'bldr>> {
        let mut builder = CardinalityResponseBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.finish()
    }

    #[inline]
    pub fn count(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(CardinalityResponse::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for CardinalityResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct CardinalityResponseArgs {
    pub count: u64,
}
impl<'a> Default for CardinalityResponseArgs {
    #[inline]
    fn default() -> Self {
        CardinalityResponseArgs { count: 0 }
    }
}

pub struct CardinalityResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CardinalityResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_count(&mut self, count: u64) {
        self.fbb_
            .push_slot::<u64>(CardinalityResponse::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CardinalityResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CardinalityResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CardinalityResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CardinalityResponse<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CardinalityResponse");
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum PostingStatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PostingStat<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PostingStat<'a> {
    type Inner = PostingStat<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PostingStat<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PostingStat { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PostingStatArgs<'args>,
    ) -> flatbuffers::WIPOffset<PostingStat<'bldr>> {
        let mut builder = PostingStatBuilder::new(_fbb);
        builder.add_count(args.count);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(PostingStat::VT_NAME, None)
        }
    }
    #[inline]
    pub fn count(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(PostingStat::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for PostingStat<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<u64>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct PostingStatArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: u64,
}
impl<'a> Default for PostingStatArgs<'a> {
    #[inline]
    fn default() -> Self {
        PostingStatArgs {
            name: None,
            count: 0,
        }
    }
}

pub struct PostingStatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PostingStatBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PostingStat::VT_NAME, name);
    }
    #[inline]
    pub fn add_count(&mut self, count: u64) {
        self.fbb_.push_slot::<u64>(PostingStat::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> PostingStatBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PostingStatBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PostingStat<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PostingStat<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PostingStat");
        ds.field("name", &self.name());
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum PostingStatsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PostingStats<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PostingStats<'a> {
    type Inner = PostingStats<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PostingStats<'a> {
    pub const VT_CARDINALITY_METRICS_STATS: flatbuffers::VOffsetT = 4;
    pub const VT_CARDINALITY_LABEL_STATS: flatbuffers::VOffsetT = 6;
    pub const VT_LABEL_VALUE_STATS: flatbuffers::VOffsetT = 8;
    pub const VT_LABEL_VALUE_PAIRS_STATS: flatbuffers::VOffsetT = 10;
    pub const VT_NUM_LABEL_PAIRS: flatbuffers::VOffsetT = 12;
    pub const VT_NUM_LABELS: flatbuffers::VOffsetT = 14;
    pub const VT_SERIES_COUNT: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PostingStats { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PostingStatsArgs<'args>,
    ) -> flatbuffers::WIPOffset<PostingStats<'bldr>> {
        let mut builder = PostingStatsBuilder::new(_fbb);
        builder.add_series_count(args.series_count);
        builder.add_num_labels(args.num_labels);
        builder.add_num_label_pairs(args.num_label_pairs);
        if let Some(x) = args.label_value_pairs_stats {
            builder.add_label_value_pairs_stats(x);
        }
        if let Some(x) = args.label_value_stats {
            builder.add_label_value_stats(x);
        }
        if let Some(x) = args.cardinality_label_stats {
            builder.add_cardinality_label_stats(x);
        }
        if let Some(x) = args.cardinality_metrics_stats {
            builder.add_cardinality_metrics_stats(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn cardinality_metrics_stats(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>(PostingStats::VT_CARDINALITY_METRICS_STATS, None)
        }
    }
    #[inline]
    pub fn cardinality_label_stats(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>(PostingStats::VT_CARDINALITY_LABEL_STATS, None)
        }
    }
    #[inline]
    pub fn label_value_stats(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>(PostingStats::VT_LABEL_VALUE_STATS, None)
        }
    }
    #[inline]
    pub fn label_value_pairs_stats(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>(PostingStats::VT_LABEL_VALUE_PAIRS_STATS, None)
        }
    }
    #[inline]
    pub fn num_label_pairs(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(PostingStats::VT_NUM_LABEL_PAIRS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn num_labels(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(PostingStats::VT_NUM_LABELS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn series_count(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(PostingStats::VT_SERIES_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for PostingStats<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>(
                "cardinality_metrics_stats",
                Self::VT_CARDINALITY_METRICS_STATS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>(
                "cardinality_label_stats",
                Self::VT_CARDINALITY_LABEL_STATS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>("label_value_stats", Self::VT_LABEL_VALUE_STATS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PostingStat>>,
            >>(
                "label_value_pairs_stats",
                Self::VT_LABEL_VALUE_PAIRS_STATS,
                false,
            )?
            .visit_field::<u64>("num_label_pairs", Self::VT_NUM_LABEL_PAIRS, false)?
            .visit_field::<u64>("num_labels", Self::VT_NUM_LABELS, false)?
            .visit_field::<u64>("series_count", Self::VT_SERIES_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct PostingStatsArgs<'a> {
    pub cardinality_metrics_stats: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>,
        >,
    >,
    pub cardinality_label_stats: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>,
        >,
    >,
    pub label_value_stats: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>,
        >,
    >,
    pub label_value_pairs_stats: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PostingStat<'a>>>,
        >,
    >,
    pub num_label_pairs: u64,
    pub num_labels: u64,
    pub series_count: u64,
}
impl<'a> Default for PostingStatsArgs<'a> {
    #[inline]
    fn default() -> Self {
        PostingStatsArgs {
            cardinality_metrics_stats: None,
            cardinality_label_stats: None,
            label_value_stats: None,
            label_value_pairs_stats: None,
            num_label_pairs: 0,
            num_labels: 0,
            series_count: 0,
        }
    }
}

pub struct PostingStatsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PostingStatsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_cardinality_metrics_stats(
        &mut self,
        cardinality_metrics_stats: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PostingStat<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            PostingStats::VT_CARDINALITY_METRICS_STATS,
            cardinality_metrics_stats,
        );
    }
    #[inline]
    pub fn add_cardinality_label_stats(
        &mut self,
        cardinality_label_stats: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PostingStat<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            PostingStats::VT_CARDINALITY_LABEL_STATS,
            cardinality_label_stats,
        );
    }
    #[inline]
    pub fn add_label_value_stats(
        &mut self,
        label_value_stats: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PostingStat<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            PostingStats::VT_LABEL_VALUE_STATS,
            label_value_stats,
        );
    }
    #[inline]
    pub fn add_label_value_pairs_stats(
        &mut self,
        label_value_pairs_stats: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PostingStat<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            PostingStats::VT_LABEL_VALUE_PAIRS_STATS,
            label_value_pairs_stats,
        );
    }
    #[inline]
    pub fn add_num_label_pairs(&mut self, num_label_pairs: u64) {
        self.fbb_
            .push_slot::<u64>(PostingStats::VT_NUM_LABEL_PAIRS, num_label_pairs, 0);
    }
    #[inline]
    pub fn add_num_labels(&mut self, num_labels: u64) {
        self.fbb_
            .push_slot::<u64>(PostingStats::VT_NUM_LABELS, num_labels, 0);
    }
    #[inline]
    pub fn add_series_count(&mut self, series_count: u64) {
        self.fbb_
            .push_slot::<u64>(PostingStats::VT_SERIES_COUNT, series_count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> PostingStatsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PostingStatsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PostingStats<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PostingStats<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PostingStats");
        ds.field(
            "cardinality_metrics_stats",
            &self.cardinality_metrics_stats(),
        );
        ds.field("cardinality_label_stats", &self.cardinality_label_stats());
        ds.field("label_value_stats", &self.label_value_stats());
        ds.field("label_value_pairs_stats", &self.label_value_pairs_stats());
        ds.field("num_label_pairs", &self.num_label_pairs());
        ds.field("num_labels", &self.num_labels());
        ds.field("series_count", &self.series_count());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PostingStats`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_posting_stats_unchecked`.
pub fn root_as_posting_stats(buf: &[u8]) -> Result<PostingStats, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<PostingStats>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PostingStats` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_posting_stats_unchecked`.
pub fn size_prefixed_root_as_posting_stats(
    buf: &[u8],
) -> Result<PostingStats, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<PostingStats>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PostingStats` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_posting_stats_unchecked`.
pub fn root_as_posting_stats_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<PostingStats<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<PostingStats<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PostingStats` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_posting_stats_unchecked`.
pub fn size_prefixed_root_as_posting_stats_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<PostingStats<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<PostingStats<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PostingStats and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PostingStats`.
pub unsafe fn root_as_posting_stats_unchecked(buf: &[u8]) -> PostingStats {
    flatbuffers::root_unchecked::<PostingStats>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PostingStats and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PostingStats`.
pub unsafe fn size_prefixed_root_as_posting_stats_unchecked(buf: &[u8]) -> PostingStats {
    flatbuffers::size_prefixed_root_unchecked::<PostingStats>(buf)
}
#[inline]
pub fn finish_posting_stats_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<PostingStats<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_posting_stats_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<PostingStats<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
